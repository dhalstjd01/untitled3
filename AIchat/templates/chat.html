<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>{{ bot_name }}와(과) 대화하기</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <link rel="stylesheet" href="{{ url_for('static', filename='css/chat.css') }}">
</head>
<body>
<div class="chat-container">
  <div class="chat-header">
    <img src="{{ profile_image }}" alt="{{ bot_name }} 프로필" class="header-profile-img" />
    <span>{{ bot_name }}</span>
    <div class="header-buttons">
      <a href="/analysis/{{ session_id }}" class="header-button">내 감정 상태 보기</a>
      <button id="new-chat-btn" class="header-button">새 대화</button>
      <button id="past-chats-btn" class="header-button">대화 목록</button>
      <a href="/" class="header-button">나가기</a>
    </div>

  </div>
  <div class="chat-messages" id="chat-messages"></div>
  <form class="chat-input-section" id="chat-form">
    <div class="chat-input-form">
      <input type="text" id="user-input" placeholder="메시지를 입력하세요..." autocomplete="off" />
      <button id="send-button" type="submit" aria-label="메시지 전송">➤</button>
    </div>
  </form>
</div>

<div id="context-menu" class="context-menu">
  <div class="context-menu-item" data-action="save-message">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17,3H5C3.89,3,3,3.89,3,5v14c0,1.1,0.89,2,2,2h14c1.1,0,2-0.9,2-2V7L17,3z M12,19c-1.66,0-3-1.34-3-3s1.34-3,3-3s3,1.34,3,3S13.66,19,12,19z M15,9H5V5h10V9z"/></svg>
    <span>메시지 저장</span>
  </div>
</div>

<div id="past-chats-modal" class="modal-overlay">
  <div class="modal-content">
    <h2>과거 대화 목록</h2>
    <div id="past-chats-list"></div>
    <button class="modal-close-btn" id="modal-close-btn">닫기</button>
  </div>
</div>

<!-- C:/Users/zxzx0/Desktop/chatbot/untitled3/AIchat/templates/chat.html -->

<script>
  /**
   * 챗봇 UI와 상호작용을 관리하는 ChatManager 객체
   */
  const ChatManager = {
    // 자주 사용하는 HTML 요소들을 미리 찾아 저장합니다.
    elements: {
      chatHeader: document.querySelector('.chat-header'), // 헤더 전체를 선택
      chatMessages: document.getElementById('chat-messages'),
      chatForm: document.getElementById('chat-form'),
      userInput: document.getElementById('user-input'),
      newChatBtn: document.getElementById('new-chat-btn'),
      pastChatsBtn: document.getElementById('past-chats-btn'),
      pastChatsModal: document.getElementById('past-chats-modal'),
      pastChatsList: document.getElementById('past-chats-list'),
      modalCloseBtn: document.getElementById('modal-close-btn'),
      contextMenu: document.getElementById('context-menu'),
    },
    // 채팅 상태 정보를 저장합니다.
    state: {
      botType: "{{ bot_type }}",
      // [수정] sessionId를 상태로 관리합니다.
      sessionId: "{{ session_id }}",
      botProfileImageSrc: document.querySelector('.header-profile-img').src,
      conversationHistory: JSON.parse({{ initial_history | tojson | safe }}),
      contextMessage: '',
    },

    /**
     * ChatManager를 초기화하고 이벤트 리스너를 바인딩합니다.
     */
    init() {
      this.bindEvents();
      this.renderHistory();
    },

    /**
     * 모든 필요한 이벤트 리스너를 등록합니다.
     */
    bindEvents() {
      this.elements.chatForm.addEventListener('submit', this.handleSendMessage.bind(this));
      this.elements.newChatBtn.addEventListener('click', this.handleNewChat.bind(this));
      this.elements.pastChatsBtn.addEventListener('click', this.openPastChatsModal.bind(this));
      this.elements.modalCloseBtn.addEventListener('click', this.closeModal.bind(this));
      this.elements.pastChatsModal.addEventListener('click', (e) => {
        if (e.target === this.elements.pastChatsModal) this.closeModal();
      });

      this.elements.pastChatsList.addEventListener('click', this.handlePastChatClick.bind(this));
      this.elements.chatMessages.addEventListener('contextmenu', this.handleMessageContextMenu.bind(this));
      this.elements.contextMenu.addEventListener('click', this.handleContextMenuAction.bind(this));

      window.addEventListener('click', () => this.elements.contextMenu.style.display = 'none');
    },

    /**
     * 현재 대화 기록을 화면에 렌더링합니다.
     */
    renderHistory() {
      this.elements.chatMessages.innerHTML = '';
      this.state.conversationHistory.forEach(msg => this.addMessage(msg.content, msg.role, false));
      this.elements.chatMessages.scrollTop = this.elements.chatMessages.scrollHeight;
    },

    /**
     * 채팅창에 새로운 메시지를 추가합니다.
     */
    addMessage(text, sender, doScroll = true) {
      const cssSender = sender === 'assistant' ? 'bot' : sender;
      let messageElement;

      if (cssSender === 'bot') {
        messageElement = document.createElement('div');
        messageElement.className = 'message-row bot';
        messageElement.innerHTML = `
            <img src="${this.state.botProfileImageSrc}" class="message-profile-img" alt="챗봇 프로필">
            <div class="message bot-message" data-message="${encodeURIComponent(text)}"></div>
          `;
        messageElement.querySelector('.bot-message').innerText = text;
      } else {
        messageElement = document.createElement('div');
        messageElement.className = 'message user-message';
        messageElement.textContent = text;
      }

      this.elements.chatMessages.appendChild(messageElement);
      if (doScroll) this.elements.chatMessages.scrollTop = this.elements.chatMessages.scrollHeight;
    },

    /**
     * '입력 중...' 인디케이터를 표시/제거합니다.
     */
    showTypingIndicator() {
      if (document.getElementById('typing-indicator')) return;
      const typingIndicator = document.createElement('div');
      typingIndicator.className = 'message-row bot';
      typingIndicator.id = 'typing-indicator';
      typingIndicator.innerHTML = `
          <img src="${this.state.botProfileImageSrc}" class="message-profile-img" alt="챗봇 프로필">
          <div class="message bot-message typing-indicator">
            <div class="typing-dots"><span></span><span></span><span></span></div>
          </div>
        `;
      this.elements.chatMessages.appendChild(typingIndicator);
      this.elements.chatMessages.scrollTop = this.elements.chatMessages.scrollHeight;
    },

    removeTypingIndicator() {
      const typingIndicator = document.getElementById('typing-indicator');
      if (typingIndicator) typingIndicator.remove();
    },

    /**
     * 사용자 메시지를 서버로 전송하고 응답을 처리합니다.
     */
    async handleSendMessage(event) {
      event.preventDefault();
      const message = this.elements.userInput.value.trim();
      if (!message) return;

      this.addMessage(message, 'user');
      this.elements.userInput.value = '';
      this.showTypingIndicator();

      this.state.conversationHistory.push({ role: 'user', content: message });

      try {
        const response = await fetch('/api/chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ message: message, bot_type: this.state.botType }),
        });
        const data = await response.json();
        if (data.error) throw new Error(data.error);

        this.addMessage(data.response, 'bot');
        this.state.conversationHistory.push({ role: 'assistant', content: data.response });
      } catch (error) {
        console.error('Error:', error);
        this.addMessage('죄송합니다, 응답을 받아오는 중 오류가 발생했어요.', 'bot');
      } finally {
        this.removeTypingIndicator();
      }
    },

    /**
     * '새 대화' 버튼 클릭을 처리합니다.
     */
    async handleNewChat() {
      if (!confirm('현재 대화를 보관하고 새 대화를 시작하시겠습니까?')) return;
      try {
        const response = await fetch('/api/new_chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ bot_type: this.state.botType }),
        });
        const data = await response.json();
        if (data.error) throw new Error(data.error);

        // [핵심 수정] 상태와 UI를 모두 업데이트합니다.
        this.state.conversationHistory = data.history;
        this.state.sessionId = data.session_id;
        this.updateAnalysisLink(); // 링크 업데이트 함수 호출
        this.renderHistory();

      } catch (error) {
        alert('새 대화를 시작하는 중 오류가 발생했습니다.');
      }
    },

    /**
     * '내 감정 상태 보기' 링크의 href 속성을 업데이트합니다.
     */
    updateAnalysisLink() {
      const analysisLink = this.elements.chatHeader.querySelector('a[href^="/analysis/"]');
      if (analysisLink) {
        analysisLink.href = `/analysis/${this.state.sessionId}`;
      }
    },

    /**
     * 과거 대화 목록 모달을 열고 데이터를 불러옵니다.
     */
    async openPastChatsModal() {
      try {
        const response = await fetch(`/api/past_chats?bot_type=${this.state.botType}`);
        const chats = await response.json();
        const listContainer = this.elements.pastChatsList;
        listContainer.innerHTML = '';

        if (chats.length === 0) {
          listContainer.innerHTML = '<p>보관된 대화가 없습니다.</p>';
        } else {
          chats.forEach(chat => {
            const itemHTML = `
                <div class="past-chat-item" data-session-id="${chat.id}">
                  <div class="past-chat-info" data-action="load">
                    <div class="session-name">${chat.session_name || '이름 없는 대화'}</div>
                    <div class="session-date">${new Date(chat.created_at).toLocaleString('ko-KR')}</div>
                  </div>
                  <button class="session-delete-btn" data-action="delete" title="대화 삭제" aria-label="대화 삭제">&times;</button>
                </div>
              `;
            listContainer.insertAdjacentHTML('beforeend', itemHTML);
          });
        }
        this.elements.pastChatsModal.style.display = 'flex';
      } catch (error) {
        alert('과거 대화 목록을 불러오는 중 오류가 발생했습니다.');
        console.error('Error fetching past chats:', error);
      }
    },

    /**
     * 모달 창을 닫습니다.
     */
    closeModal() {
      this.elements.pastChatsModal.style.display = 'none';
    },

    /**
     * 과거 대화 목록의 클릭 이벤트를 위임하여 처리합니다.
     */
    handlePastChatClick(e) {
      const actionTarget = e.target.closest('[data-action]');
      if (!actionTarget) return;

      const action = actionTarget.dataset.action;
      const item = actionTarget.closest('.past-chat-item');
      if (!item) return;

      const sessionId = item.dataset.sessionId;
      if (action === 'load') this.handleLoadChat(sessionId);
      if (action === 'delete') this.handleDeleteSession(sessionId);
    },

    /**
     * 선택한 과거 대화를 불러옵니다.
     */
    async handleLoadChat(sessionId) {
      if (!confirm('이 대화를 불러오시겠습니까? 현재 대화는 보관됩니다.')) return;
      try {
        const response = await fetch('/api/load_chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ bot_type: this.state.botType, session_id: sessionId }),
        });
        const data = await response.json();
        if (data.error) throw new Error(data.error);

        // [핵심 수정] 불러온 대화의 세션 ID도 업데이트합니다.
        this.state.conversationHistory = data.history;
        this.state.sessionId = sessionId;
        this.updateAnalysisLink();
        this.renderHistory();
        this.closeModal();

      } catch (error) {
        alert('대화를 불러오는 중 오류가 발생했습니다.');
      }
    },

    /**
     * 선택한 대화 세션을 삭제합니다.
     */
    async handleDeleteSession(sessionId) {
      if (!confirm('이 대화 기록을 정말로 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.')) return;
      try {
        const response = await fetch('/api/delete_session', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ session_id: sessionId }),
        });
        const result = await response.json();
        if (result.status === 'success') {
          const itemToRemove = this.elements.pastChatsList.querySelector(`[data-session-id="${sessionId}"]`);
          if (itemToRemove) itemToRemove.remove();
          if (this.elements.pastChatsList.children.length === 0) {
            this.elements.pastChatsList.innerHTML = '<p>보관된 대화가 없습니다.</p>';
          }
        } else {
          alert(result.message || '삭제에 실패했습니다.');
        }
      } catch (error) {
        alert('대화 삭제 중 오류가 발생했습니다.');
      }
    },

    /**
     * 메시지 우클릭 시 컨텍스트 메뉴를 표시합니다.
     */
    handleMessageContextMenu(e) {
      const target = e.target.closest('.bot-message');
      if (!target) return;

      e.preventDefault();
      this.state.contextMessage = decodeURIComponent(target.dataset.message);
      const menu = this.elements.contextMenu;
      menu.style.left = `${e.clientX}px`;
      menu.style.top = `${e.clientY}px`;
      menu.style.display = 'block';
    },

    /**
     * 컨텍스트 메뉴의 액션을 처리합니다.
     */
    handleContextMenuAction(e) {
      const action = e.target.closest('[data-action]').dataset.action;
      if (action === 'save-message') {
        this.saveMessage(this.state.contextMessage);
      }
      this.elements.contextMenu.style.display = 'none';
    },

    /**
     * 메시지를 '좋아요' 목록에 저장합니다.
     */
    async saveMessage(text) {
      try {
        const response = await fetch('/api/like_message', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ bot_type: this.state.botType, message: text }),
        });
        const data = await response.json();
        alert(data.message || (data.status === 'success' ? '메시지가 저장되었습니다.' : '저장에 실패했습니다.'));
      } catch (error) {
        alert('메시지 저장 중 오류가 발생했습니다.');
      }
    },
  };

  // DOM이 완전히 로드된 후 ChatManager를 실행합니다.
  window.addEventListener('DOMContentLoaded', () => ChatManager.init());
</script>
</body>
</html>