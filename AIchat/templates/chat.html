<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <title>{{ bot_name }}와(과) 대화하기</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <link rel="stylesheet" href="{{ url_for('static', filename='css/chat.css') }}">
</head>
<body>

<div class="gradient-bg"></div>

<div class="chat-container">
    <div class="chat-layout">

        <div class="sidebar">
            <div class="sidebar-header">
                <h2>대화 목록</h2>
                <button id="new-chat-btn" class="new-chat-button" title="새 대화 시작하기">+</button>
            </div>
            <div class="chat-list-container">
                <ul id="chat-list">
                </ul>
            </div>
        </div>

        <div class="main-content">
            <div class="chat-header">
                <img src="{{ profile_image }}" alt="{{ bot_name }} 프로필" class="header-profile-img" />
                <span>{{ bot_name }}</span>
                <div class="header-buttons">
                    <a href="/analysis/{{ session_id }}" class="header-button">내 감정 상태 보기</a>
                    <a href="/" class="header-button">나가기</a>
                </div>
            </div>
            <div class="chat-messages" id="chat-messages"></div>
            <form class="chat-input-section" id="chat-form">
                <div class="chat-input-form">
                    <input type="text" id="user-input" placeholder="메시지를 입력하세요..." autocomplete="off" />
                    <button id="send-button" type="submit" aria-label="메시지 전송">➤</button>
                </div>
            </form>
        </div>
    </div>
</div>

<div id="context-menu" class="context-menu">
    <div class="context-menu-item" data-action="save-message">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17,3H5C3.89,3,3,3.89,3,5v14c0,1.1,0.89,2,2,2h14c1.1,0,2-0.9,2-2V7L17,3z M12,19c-1.66,0-3-1.34-3-3s1.34-3,3-3s3,1.34,3,3S13.66,19,12,19z M15,9H5V5h10V9z"/></svg>
        <span>메시지 저장</span>
    </div>
</div>

<script>
    const ChatManager = {
        elements: {
            chatHeader: document.querySelector('.chat-header'),
            chatMessages: document.getElementById('chat-messages'),
            chatForm: document.getElementById('chat-form'),
            userInput: document.getElementById('user-input'),
            newChatBtn: document.getElementById('new-chat-btn'),
            chatList: document.getElementById('chat-list'),
            contextMenu: document.getElementById('context-menu'),
        },
        state: {
            botType: "{{ bot_type }}",
            sessionId: "{{ session_id }}",
            botProfileImageSrc: document.querySelector('.header-profile-img').src,
            conversationHistory: JSON.parse({{ initial_history | tojson | safe }}),
    contextMessage: '',
    },
    init() {
        this.bindEvents();
        this.renderHistory();
        this.loadSidebarChats();
    },
    bindEvents() {
        this.elements.chatForm.addEventListener('submit', this.handleSendMessage.bind(this));
        this.elements.newChatBtn.addEventListener('click', this.handleNewChat.bind(this));
        this.elements.chatMessages.addEventListener('contextmenu', this.handleMessageContextMenu.bind(this));
        this.elements.contextMenu.addEventListener('click', this.handleContextMenuAction.bind(this));
        window.addEventListener('click', () => this.elements.contextMenu.style.display = 'none');
        this.elements.chatList.addEventListener('click', this.handleSidebarClick.bind(this));
    },
    async loadSidebarChats() {
        try {
            const [currentRes, pastRes] = await Promise.all([
                fetch(`/api/get_session_info?session_id=${this.state.sessionId}`),
                fetch(`/api/past_chats?bot_type=${this.state.botType}`)
            ]);
            if (!currentRes.ok || !pastRes.ok) throw new Error('Failed to fetch chat lists');
            const currentChat = await currentRes.json();
            const pastChats = await pastRes.json();
            this.elements.chatList.innerHTML = '';
            this.addChatItemToSidebar(currentChat, true);
            pastChats.forEach(chat => this.addChatItemToSidebar(chat, false));
        } catch (error) {
            console.error('Error fetching chats:', error);
            this.elements.chatList.innerHTML = '<li>대화 목록 로딩 실패</li>';
        }
    },
    addChatItemToSidebar(chat, isActive) {
        const item = document.createElement('li');
        item.className = 'chat-list-item';
        item.dataset.sessionId = chat.id;
        if (isActive) item.classList.add('active');

        // ⭐ [핵심 수정] 삭제 버튼의 텍스트(&times;)를 SVG 아이콘으로 교체
        item.innerHTML = `
            <div class="chat-item-info" data-action="load">
                <div class="session-name">${chat.session_name || '새로운 대화'}</div>
                <div class="session-date">${new Date(chat.created_at).toLocaleString('ko-KR', { dateStyle: 'short', timeStyle: 'short' })}</div>
            </div>
            <button class="session-delete-btn" data-action="delete" title="대화 삭제">
                <svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24"><path d="M0 0h24v24H0z" fill="none"/><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg>
            </button>
        `;
        this.elements.chatList.appendChild(item);
    },
    updateActiveChatItem(sessionId) {
        this.elements.chatList.querySelectorAll('.chat-list-item').forEach(item => {
            item.classList.remove('active');
            if (item.dataset.sessionId === sessionId.toString()) item.classList.add('active');
        });
    },
    handleSidebarClick(event) {
        const actionTarget = event.target.closest('[data-action]');
        if (!actionTarget) return;
        const action = actionTarget.dataset.action;
        const targetItem = actionTarget.closest('.chat-list-item');
        const sessionId = targetItem.dataset.sessionId;
        if (action === 'load' && sessionId !== this.state.sessionId) this.handleLoadChat(sessionId);
        else if (action === 'delete') this.handleDeleteSession(sessionId, targetItem);
    },
    async handleDeleteSession(sessionId, listItemElement) {
        if (sessionId === this.state.sessionId) {
            alert('현재 대화는 삭제할 수 없습니다. 다른 대화를 선택 후 시도해주세요.');
            return;
        }
        if (!confirm('이 대화 기록을 정말로 삭제하시겠습니까?')) return;
        try {
            const response = await fetch('/api/delete_session', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ session_id: sessionId }),
            });
            const result = await response.json();
            if (result.status === 'success') listItemElement.remove();
            else alert(result.message || '삭제에 실패했습니다.');
        } catch (error) {
            alert('대화 삭제 중 오류가 발생했습니다.');
        }
    },
    async handleLoadChat(sessionId) {
        try {
            const response = await fetch('/api/load_chat', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ bot_type: this.state.botType, session_id: sessionId }),
            });
            const data = await response.json();
            if (data.error) throw new Error(data.error);
            this.state.conversationHistory = data.history;
            this.state.sessionId = sessionId;
            this.updateActiveChatItem(sessionId);
            this.updateAnalysisLink();
            this.renderHistory();
        } catch (error) {
            alert('대화를 불러오는 중 오류가 발생했습니다.');
        }
    },
    async handleNewChat() {
        if (!confirm('새 대화를 시작하시겠습니까?')) return;
        try {
            const response = await fetch('/api/new_chat', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ bot_type: this.state.botType }),
            });
            const data = await response.json();
            if (data.error) throw new Error(data.error);
            this.state.conversationHistory = data.history;
            this.state.sessionId = data.session_id;
            this.renderHistory();
            this.loadSidebarChats();
            this.updateAnalysisLink();
        } catch (error) {
            alert('새 대화를 시작하는 중 오류가 발생했습니다.');
        }
    },
    renderHistory() {
        this.elements.chatMessages.innerHTML = '';
        this.state.conversationHistory.forEach(msg => this.addMessage(msg.content, msg.role, false));
        this.elements.chatMessages.scrollTop = this.elements.chatMessages.scrollHeight;
    },
    updateAnalysisLink() {
        const analysisLink = document.querySelector('a[href^="/analysis/"]');
        if (analysisLink) analysisLink.href = `/analysis/${this.state.sessionId}`;
    },
    addMessage(text, sender, doScroll = true) {
        const cssSender = sender === 'assistant' ? 'bot' : sender;
        let messageElement;
        if (cssSender === 'bot') {
            messageElement = document.createElement('div');
            messageElement.className = 'message-row bot';
            messageElement.innerHTML = `<img src="${this.state.botProfileImageSrc}" class="message-profile-img" alt="챗봇 프로필"><div class="message bot-message" data-message="${encodeURIComponent(text)}"></div>`;
            messageElement.querySelector('.bot-message').innerText = text;
        } else {
            messageElement = document.createElement('div');
            messageElement.className = 'message user-message';
            messageElement.textContent = text;
        }
        this.elements.chatMessages.appendChild(messageElement);
        if (doScroll) this.elements.chatMessages.scrollTop = this.elements.chatMessages.scrollHeight;
    },
    async handleSendMessage(event) {
        event.preventDefault();
        const message = this.elements.userInput.value.trim();
        if (!message) return;
        this.addMessage(message, 'user');
        this.elements.userInput.value = '';
        this.showTypingIndicator();
        this.state.conversationHistory.push({ role: 'user', content: message });
        try {
            const response = await fetch('/api/chat', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ message: message, bot_type: this.state.botType }),
            });
            const data = await response.json();
            if (data.error) throw new Error(data.error);
            this.removeTypingIndicator();
            this.addMessage(data.response, 'bot');
            this.state.conversationHistory.push({ role: 'assistant', content: data.response });
        } catch (error) {
            console.error('Error:', error);
            this.removeTypingIndicator();
            this.addMessage('죄송합니다, 응답을 받아오는 중 오류가 발생했어요.', 'bot');
        }
    },
    showTypingIndicator() {
        if (document.getElementById('typing-indicator')) return;
        const indicator = document.createElement('div');
        indicator.id = 'typing-indicator';
        indicator.className = 'message-row bot';
        indicator.innerHTML = `<img src="${this.state.botProfileImageSrc}" class="message-profile-img" alt="..."><div class="message bot-message typing-indicator"><div class="typing-dots"><span></span><span></span><span></span></div></div>`;
        this.elements.chatMessages.appendChild(indicator);
        this.elements.chatMessages.scrollTop = this.elements.chatMessages.scrollHeight;
    },
    removeTypingIndicator() {
        const indicator = document.getElementById('typing-indicator');
        if (indicator) indicator.remove();
    },
    handleMessageContextMenu(e) {
        const target = e.target.closest('.bot-message');
        if (!target) return;
        e.preventDefault();
        this.state.contextMessage = decodeURIComponent(target.dataset.message);
        const menu = this.elements.contextMenu;
        menu.style.left = `${e.clientX}px`;
        menu.style.top = `${e.clientY}px`;
        menu.style.display = 'block';
    },
    handleContextMenuAction(e) {
        const action = e.target.closest('[data-action]').dataset.action;
        if (action === 'save-message') this.saveMessage(this.state.contextMessage);
        this.elements.contextMenu.style.display = 'none';
    },
    async saveMessage(text) {
        try {
            const response = await fetch('/api/like_message', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ bot_type: this.state.botType, message: text }),
            });
            const data = await response.json();
            alert(data.message || '메시지가 저장되었습니다.');
        } catch (error) {
            alert('메시지 저장 중 오류가 발생했습니다.');
        }
    },
    };
    window.addEventListener('pageshow', (event) => {
        if (event.persisted) ChatManager.loadSidebarChats();
    });
    window.addEventListener('DOMContentLoaded', () => ChatManager.init());
</script>
</body>
</html>