<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <title>{{ bot_name }}와(과) 대화하기</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <link rel="stylesheet" href="{{ url_for('static', filename='css/chat.css') }}">
</head>
<body>
<div class="chat-container">
    <div class="chat-header">
        <img src="{{ profile_image }}" alt="{{ bot_name }} 프로필" class="header-profile-img" />
        <span>{{ bot_name }}</span>
        <div class="header-buttons">
            <a href="/analysis/{{ session_id }}" class="header-button">내 감정 상태 보기</a>
            <button id="new-chat-btn" class="header-button">새 대화</button>
            <button id="past-chats-btn" class="header-button">대화 목록</button>
            <a href="/" class="header-button">나가기</a>
        </div>

    </div>
    <div class="chat-messages" id="chat-messages"></div>
    <form class="chat-input-section" id="chat-form">
        <div class="chat-input-form">
            <input type="text" id="user-input" placeholder="메시지를 입력하세요..." autocomplete="off" />
            <button id="send-button" type="submit" aria-label="메시지 전송">➤</button>
        </div>
    </form>
</div>

<div id="context-menu" class="context-menu">
    <div class="context-menu-item" data-action="save-message">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17,3H5C3.89,3,3,3.89,3,5v14c0,1.1,0.89,2,2,2h14c1.1,0,2-0.9,2-2V7L17,3z M12,19c-1.66,0-3-1.34-3-3s1.34-3,3-3s3,1.34,3,3S13.66,19,12,19z M15,9H5V5h10V9z"/></svg>
        <span>메시지 저장</span>
    </div>
</div>

<div id="past-chats-modal" class="modal-overlay">
    <div class="modal-content">
        <h2>과거 대화 목록</h2>
        <div id="past-chats-list"></div>
        <button class="modal-close-btn" id="modal-close-btn">닫기</button>
    </div>
</div>

<script>
    const ChatManager = {
        elements: {
            chatHeader: document.querySelector('.chat-header'),
            chatMessages: document.getElementById('chat-messages'),
            chatForm: document.getElementById('chat-form'),
            userInput: document.getElementById('user-input'),
            newChatBtn: document.getElementById('new-chat-btn'),
            pastChatsBtn: document.getElementById('past-chats-btn'),
            pastChatsModal: document.getElementById('past-chats-modal'),
            pastChatsList: document.getElementById('past-chats-list'),
            modalCloseBtn: document.getElementById('modal-close-btn'),
            contextMenu: document.getElementById('context-menu'),
        },
        state: {
            botType: "{{ bot_type }}",
            sessionId: "{{ session_id }}",
            botProfileImageSrc: document.querySelector('.header-profile-img').src,
            conversationHistory: JSON.parse({{ initial_history | tojson | safe }}),
    contextMessage: '',
    },

    init() {
        this.bindEvents();
        this.renderHistory();
    },

    bindEvents() {
        this.elements.chatForm.addEventListener('submit', this.handleSendMessage.bind(this));
        this.elements.newChatBtn.addEventListener('click', this.handleNewChat.bind(this));
        this.elements.pastChatsBtn.addEventListener('click', this.openPastChatsModal.bind(this));
        this.elements.modalCloseBtn.addEventListener('click', this.closeModal.bind(this));
        this.elements.pastChatsModal.addEventListener('click', (e) => {
            if (e.target === this.elements.pastChatsModal) this.closeModal();
        });

        this.elements.pastChatsList.addEventListener('click', this.handlePastChatClick.bind(this));
        this.elements.chatMessages.addEventListener('contextmenu', this.handleMessageContextMenu.bind(this));
        this.elements.contextMenu.addEventListener('click', this.handleContextMenuAction.bind(this));

        window.addEventListener('click', () => this.elements.contextMenu.style.display = 'none');
    },

    renderHistory() {
        this.elements.chatMessages.innerHTML = '';
        this.state.conversationHistory.forEach(msg => this.addMessage(msg.content, msg.role, false));
        this.elements.chatMessages.scrollTop = this.elements.chatMessages.scrollHeight;
    },

    addMessage(text, sender, doScroll = true) {
        const cssSender = sender === 'assistant' ? 'bot' : sender;
        let messageElement;

        if (cssSender === 'bot') {
            messageElement = document.createElement('div');
            messageElement.className = 'message-row bot';
            messageElement.innerHTML = `
            <img src="${this.state.botProfileImageSrc}" class="message-profile-img" alt="챗봇 프로필">
            <div class="message bot-message" data-message="${encodeURIComponent(text)}"></div>
          `;
            messageElement.querySelector('.bot-message').innerText = text;
        } else {
            messageElement = document.createElement('div');
            messageElement.className = 'message user-message';
            messageElement.textContent = text;
        }

        this.elements.chatMessages.appendChild(messageElement);
        if (doScroll) this.elements.chatMessages.scrollTop = this.elements.chatMessages.scrollHeight;
    },

    showTypingIndicator() {
        if (document.getElementById('typing-indicator')) return;
        const typingIndicator = document.createElement('div');
        typingIndicator.className = 'message-row bot';
        typingIndicator.id = 'typing-indicator';
        typingIndicator.innerHTML = `
          <img src="${this.state.botProfileImageSrc}" class="message-profile-img" alt="챗봇 프로필">
          <div class="message bot-message typing-indicator">
            <div class="typing-dots"><span></span><span></span><span></span></div>
          </div>
        `;
        this.elements.chatMessages.appendChild(typingIndicator);
        this.elements.chatMessages.scrollTop = this.elements.chatMessages.scrollHeight;
    },

    removeTypingIndicator() {
        const typingIndicator = document.getElementById('typing-indicator');
        if (typingIndicator) typingIndicator.remove();
    },

    async handleSendMessage(event) {
        event.preventDefault();
        const message = this.elements.userInput.value.trim();
        if (!message) return;

        this.addMessage(message, 'user');
        this.elements.userInput.value = '';
        this.showTypingIndicator();

        this.state.conversationHistory.push({ role: 'user', content: message });

        try {
            const response = await fetch('/api/chat', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ message: message, bot_type: this.state.botType }),
            });
            const data = await response.json();
            if (data.error) throw new Error(data.error);

            this.addMessage(data.response, 'bot');
            this.state.conversationHistory.push({ role: 'assistant', content: data.response });
        } catch (error) {
            console.error('Error:', error);
            this.addMessage('죄송합니다, 응답을 받아오는 중 오류가 발생했어요.', 'bot');
        } finally {
            this.removeTypingIndicator();
        }
    },

    async handleNewChat() {
        if (!confirm('현재 대화를 보관하고 새 대화를 시작하시겠습니까?')) return;
        try {
            const response = await fetch('/api/new_chat', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ bot_type: this.state.botType }),
            });
            const data = await response.json();
            if (data.error) throw new Error(data.error);

            this.state.conversationHistory = data.history;
            this.state.sessionId = data.session_id;
            this.updateAnalysisLink();
            this.renderHistory();

        } catch (error) {
            alert('새 대화를 시작하는 중 오류가 발생했습니다.');
        }
    },

    updateAnalysisLink() {
        const analysisLink = this.elements.chatHeader.querySelector('a[href^="/analysis/"]');
        if (analysisLink) {
            analysisLink.href = `/analysis/${this.state.sessionId}`;
        }
    },

    async openPastChatsModal() {
        try {
            const response = await fetch(`/api/past_chats?bot_type=${this.state.botType}`);
            const chats = await response.json();
            const listContainer = this.elements.pastChatsList;
            listContainer.innerHTML = '';

            if (chats.length === 0) {
                listContainer.innerHTML = '<p>보관된 대화가 없습니다.</p>';
            } else {
                chats.forEach(chat => {
                    const itemHTML = `
                <div class="past-chat-item" data-session-id="${chat.id}">
                  <div class="past-chat-info" data-action="load">
                    <div class="session-name">${chat.session_name || '이름 없는 대화'}</div>
                    <div class="session-date">${new Date(chat.created_at).toLocaleString('ko-KR')}</div>
                  </div>
                  <button class="session-delete-btn" data-action="delete" title="대화 삭제" aria-label="대화 삭제">&times;</button>
                </div>
              `;
                    listContainer.insertAdjacentHTML('beforeend', itemHTML);
                });
            }
            this.elements.pastChatsModal.style.display = 'flex';
        } catch (error) {
            alert('과거 대화 목록을 불러오는 중 오류가 발생했습니다.');
            console.error('Error fetching past chats:', error);
        }
    },

    closeModal() {
        this.elements.pastChatsModal.style.display = 'none';
    },

    handlePastChatClick(e) {
        const actionTarget = e.target.closest('[data-action]');
        if (!actionTarget) return;

        const action = actionTarget.dataset.action;
        const item = actionTarget.closest('.past-chat-item');
        if (!item) return;

        const sessionId = item.dataset.sessionId;
        if (action === 'load') this.handleLoadChat(sessionId);
        if (action === 'delete') this.handleDeleteSession(sessionId);
    },

    async handleLoadChat(sessionId) {
        if (!confirm('이 대화를 불러오시겠습니까? 현재 대화는 보관됩니다.')) return;
        try {
            const response = await fetch('/api/load_chat', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ bot_type: this.state.botType, session_id: sessionId }),
            });
            const data = await response.json();
            if (data.error) throw new Error(data.error);

            this.state.conversationHistory = data.history;
            this.state.sessionId = sessionId;
            this.updateAnalysisLink();
            this.renderHistory();
            this.closeModal();

        } catch (error) {
            alert('대화를 불러오는 중 오류가 발생했습니다.');
        }
    },

    async handleDeleteSession(sessionId) {
        if (!confirm('이 대화 기록을 정말로 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.')) return;
        try {
            const response = await fetch('/api/delete_session', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ session_id: sessionId }),
            });
            const result = await response.json();
            if (result.status === 'success') {
                const itemToRemove = this.elements.pastChatsList.querySelector(`[data-session-id="${sessionId}"]`);
                if (itemToRemove) itemToRemove.remove();
                if (this.elements.pastChatsList.children.length === 0) {
                    this.elements.pastChatsList.innerHTML = '<p>보관된 대화가 없습니다.</p>';
                }
            } else {
                alert(result.message || '삭제에 실패했습니다.');
            }
        } catch (error) {
            alert('대화 삭제 중 오류가 발생했습니다.');
        }
    },

    handleMessageContextMenu(e) {
        const target = e.target.closest('.bot-message');
        if (!target) return;

        e.preventDefault();
        this.state.contextMessage = decodeURIComponent(target.dataset.message);
        const menu = this.elements.contextMenu;
        menu.style.left = `${e.clientX}px`;
        menu.style.top = `${e.clientY}px`;
        menu.style.display = 'block';
    },

    handleContextMenuAction(e) {
        const action = e.target.closest('[data-action]').dataset.action;
        if (action === 'save-message') {
            this.saveMessage(this.state.contextMessage);
        }
        this.elements.contextMenu.style.display = 'none';
    },

    async saveMessage(text) {
        try {
            const response = await fetch('/api/like_message', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ bot_type: this.state.botType, message: text }),
            });
            const data = await response.json();
            alert(data.message || (data.status === 'success' ? '메시지가 저장되었습니다.' : '저장에 실패했습니다.'));
        } catch (error) {
            alert('메시지 저장 중 오류가 발생했습니다');
        }
    },
    };

    window.addEventListener('DOMContentLoaded', () => ChatManager.init());
</script>
</body>
</html>